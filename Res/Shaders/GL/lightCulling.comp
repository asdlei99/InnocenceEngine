// shadertype=glsl
#version 450
#extension GL_ARB_shader_image_load_store : require
#define BLOCK_SIZE 16

layout(local_size_x = BLOCK_SIZE, local_size_y = BLOCK_SIZE, local_size_z = 1) in;

struct Plane
{
	vec3 N;
	float d;
};

Plane ComputePlane(vec3 p0, vec3 p1, vec3 p2)
{
	Plane plane;

	vec3 v0 = p1 - p0;
	vec3 v2 = p2 - p0;

	plane.N = normalize(cross(v0, v2));
	plane.d = dot(plane.N, p0);

	return plane;
}

struct Frustum
{
	Plane planes[4]; // LRTB
};

struct Sphere
{
	vec3 c;
	float r;
};

bool SphereInsidePlane(Sphere sphere, Plane plane)
{
	return dot(plane.N, sphere.c) - plane.d < -sphere.r;
}

bool SphereInsideFrustum(Sphere sphere, Frustum frustum, float zNear, float zFar)
{
	bool result = true;

	if (sphere.c.z - sphere.r > zNear || sphere.c.z + sphere.r < zFar)
	{
		result = false;
	}

	for (int i = 0; i < 4 && result; i++)
	{
		if (SphereInsidePlane(sphere, frustum.planes[i]))
		{
			result = false;
		}
	}

	return result;
}

vec4 ClipToView(vec4 clip, mat4 in_p_inv)
{
	// View space position.
	vec4 view = in_p_inv * clip;
	// Perspective projection.
	view = view / view.w;

	return view;
}

vec4 ScreenToView(vec4 screen, vec2 in_viewportSize, mat4 in_p_inv)
{
	// Convert to normalized texture coordinates
	vec2 writeTexCoord = screen.xy / in_viewportSize;

	// Convert to clip space
	vec4 clip = vec4(vec2(writeTexCoord.x, writeTexCoord.y) * 2.0f - 1.0f, screen.z, screen.w);

	return ClipToView(clip, in_p_inv);
}

// w component of luminance is attenuationRadius
struct pointLight {
	vec4 position;
	vec4 luminance;
	//float attenuationRadius;
};

const int NR_POINT_LIGHTS = 1024;

layout(std140, row_major, binding = 0) uniform cameraUBO
{
	mat4 uni_p_camera_original;
	mat4 uni_p_camera_jittered;
	mat4 uni_r_camera;
	mat4 uni_t_camera;
	mat4 uni_r_camera_prev;
	mat4 uni_t_camera_prev;
	vec4 uni_globalPos;
	float WHRatio;
	float zNear;
	float zFar;
};

layout(std140, row_major, binding = 4) uniform pointLightUBO
{
	pointLight uni_pointLights[NR_POINT_LIGHTS];
};

layout(std140, row_major, binding = 7) uniform skyUBO
{
	mat4 p_inv;
	mat4 v_inv;
	vec2 viewportSize;
};

layout(std140, binding = 8) uniform dispatchParamsUBO
{
	uvec3 numThreadGroups;
	uint dispatchParamsUBO_padding1;
	uvec3 numThreads;
	uint dispatchParamsUBO_padding2;
};

layout(std430, binding = 0) buffer gridFrustumsSSBO
{
	Frustum gridFrustums[];
};

layout(std430, binding = 1) buffer lightListIndexCounterSSBO
{
	uint lightListIndexCounter;
};

layout(std430, binding = 2) buffer lightIndexListSSBO
{
	uint lightIndexList[];
};

layout(binding = 0) uniform usampler2D depthTexture;
layout(binding = 1, rgba16f) uniform volatile coherent image2D uni_lightGrid;
layout(binding = 2, rgba16f) uniform volatile coherent image2D uni_debugTexture;

shared uint l_uMinDepth;
shared uint l_uMaxDepth;
shared Frustum l_TileFrustum;
shared uint l_LightCount;
shared uint l_LightIndexStartOffset;
shared uint l_LightList[1024];

const vec4 heatArray[8] = {
	vec4(0.0f, 0.0f, 0.5f, 1.0f),
	vec4(0.0f, 0.0f, 1.0f, 1.0f),
	vec4(0.0f, 1.0f, 0.5f, 1.0f),
	vec4(0.0f, 1.0f, 1.0f, 1.0f),
	vec4(0.0f, 0.5f, 0.0f, 1.0f),
	vec4(0.0f, 1.0f, 0.0f, 1.0f),
	vec4(1.0f, 1.0f, 0.0f, 1.0f),
	vec4(1.0f, 0.0f, 0.0f, 1.0f)
};

void AppendLight(uint lightIndex)
{
	uint index = l_LightCount; // Index into the visible lights array.
	atomicAdd(l_LightCount, 1);
	if (index < 1024)
	{
		l_LightList[index] = lightIndex;
	}
}

vec4 RG32UI2RGBA16F(uvec2 rhs)
{
	return vec4(float(rhs.x & 0x0000FFFF), float((rhs.x & 0xFFFF0000) >> 16U), float(rhs.y & 0x0000FFFF), float((rhs.y & 0xFFFF0000) >> 16U));
	//return vec4(uintBitsToFloat(rhs.x & 0x0000FFFF),
	//	uintBitsToFloat((rhs.x & 0xFFFF0000) >> 16U),
	//	uintBitsToFloat(rhs.y & 0x0000FFFF),
	//	uintBitsToFloat((rhs.y & 0xFFFF0000) >> 16U));
}

void main()
{
	// Calculate min & max depth in threadgroup / tile.
	vec2 readTextureCoord = vec2(gl_GlobalInvocationID.xy) / viewportSize;

	uint uDepth = texture(depthTexture, readTextureCoord).r;

	ivec2 writeTexCoord = ivec2(gl_GlobalInvocationID.xy);

	// Initialize group local variables
	// Avoid contention by other threads in the group.
	if (gl_LocalInvocationIndex == 0)
	{
		l_uMinDepth = 0xffffffff;
		l_uMaxDepth = 0;
		l_LightCount = 0;
		l_LightIndexStartOffset = 0;
		l_TileFrustum = gridFrustums[gl_WorkGroupID.x + (gl_WorkGroupID.y * numThreadGroups.x)];
	}

	groupMemoryBarrier();

	// Get min/max depth
	atomicMin(l_uMinDepth, uDepth);
	atomicMax(l_uMaxDepth, uDepth);

	groupMemoryBarrier();

	float fMinDepth = uintBitsToFloat(l_uMinDepth);
	float fMaxDepth = uintBitsToFloat(l_uMaxDepth);

	// Convert depth values to view space.
	float minDepthVS = ClipToView(vec4(0, 0, fMinDepth, 1), p_inv).z;
	float maxDepthVS = ClipToView(vec4(0, 0, fMaxDepth, 1), p_inv).z;
	float nearClipVS = ClipToView(vec4(0, 0, -1, 1), p_inv).z;
	float farClipVS = ClipToView(vec4(0, 0, 1, 1), p_inv).z;

	// Clipping plane for minimum depth value
	Plane minPlane = { vec3(0, 0, -1), -minDepthVS };

	// Cull point light
	for (uint i = gl_LocalInvocationIndex; i < NR_POINT_LIGHTS; i += BLOCK_SIZE * BLOCK_SIZE)
	{
		pointLight light = uni_pointLights[i];
		// w component of luminance is the attenuation radius
		if (light.luminance.w > 0.0f)
		{
			vec4 lightPos_VS = uni_t_camera * light.position;
			lightPos_VS = uni_r_camera * lightPos_VS;
			Sphere sphere = { lightPos_VS.xyz, light.luminance.w };
			if (SphereInsideFrustum(sphere, l_TileFrustum, nearClipVS, farClipVS))
			{
				//if (!SphereInsidePlane(sphere, minPlane))
				//{
				AppendLight(i);
				//}
			}
		}
	}

	groupMemoryBarrier();

	// Only local thread 0 could write to the global light index counter and light grid
	if (gl_LocalInvocationIndex == 0)
	{
		l_LightIndexStartOffset = lightListIndexCounter;
		atomicAdd(lightListIndexCounter, l_LightCount);
		uvec2 l_lightGridValueOrig = uvec2(l_LightIndexStartOffset, l_LightCount);
		vec4 l_lightGridValueWrite = RG32UI2RGBA16F(l_lightGridValueOrig);
		imageStore(uni_lightGrid, ivec2(gl_WorkGroupID.xy), l_lightGridValueWrite);
	}

	groupMemoryBarrier();

	// Write to global light index list
	for (uint i = gl_LocalInvocationIndex; i < l_LightCount; i += BLOCK_SIZE * BLOCK_SIZE)
	{
		lightIndexList[l_LightIndexStartOffset + i] = l_LightList[i];
	}

	// Write to debug heat map texture
	imageStore(uni_debugTexture, writeTexCoord, vec4(0, 0, 0, 0));

	if (gl_LocalInvocationID.x == 0 || gl_LocalInvocationID.y == 0)
	{
		imageStore(uni_debugTexture, writeTexCoord, vec4(0, 0, 0, 0.9f));
	}
	else if (gl_LocalInvocationID.x == 1 || gl_LocalInvocationID.y == 1)
	{
		imageStore(uni_debugTexture, writeTexCoord, vec4(0, 0, 0, 0.5f));
	}
	else if (l_LightCount > 0)
	{
		vec4 heat;

		if (l_LightCount >= 8)
		{
			heat = heatArray[7];
		}
		else
		{
			heat = heatArray[l_LightCount - 1];
		}
		imageStore(uni_debugTexture, writeTexCoord, heat);
	}
	else
	{
		imageStore(uni_debugTexture, writeTexCoord, vec4(0, 0, 0, 1));
	}
}