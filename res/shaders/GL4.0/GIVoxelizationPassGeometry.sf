// shadertype=glsl
#version 400 core
layout(triangles) in;
layout(line_strip, max_vertices = 6) out;

in VS_OUT{
	vec3 normal;
} gs_in[];
out vec4 finalColor;

struct Axis
{
	float projection;
	vec3 axis;
};

// @TODO: dynamic scene main axes
const vec3 Vx = vec3(1.0f, 0.0f, 0.0f);
const vec3 Vy = vec3(0.0f, 1.0f, 0.0f);
const vec3 Vz = vec3(0.0f, 0.0f, 1.0f);

void ProjectToDominantAxis(vec3 dominantAxis, int index)
{
	gl_Position = gs_in[index].gl_position * vec4(dominantAxis, 1.0);
	finalColor = vec4(1.0, 0.0, 1.0, 1.0);
	EmitVertex();

	EndPrimitive();
}

void main()
{
	vec3 triangleNormal = gs_in[0].normal + gs_in[1].normal + gs_in[2].normal;
	triangleNormal = triangleNormal.normalize();

	Axis projOnX;
	projOnX.projection = dot(triangleNormal, Vx);
	projOnX.axis = Vx;

	Axis projOnY;
	projOnY.projection = dot(triangleNormal, Vy);
	projOnY.axis = Vy;

	Axis projOnZ;
	projOnZ.projection = dot(triangleNormal, Vz);
	projOnZ.axis = Vz;

	vec3 dominantAxis;

	if (projOnX > projOnY)
	{
		if (projOnX > projOnZ)
		{
			dominantAxis = projOnX.axis;
		}
		else
		{
			dominantAxis = projOnZ.axis;
		}
	}
	else
	{
		if (projOnY > projOnZ)
		{
			dominantAxis = projOnY.axis;
		}
		else
		{
			dominantAxis = projOnZ.axis;
		}
	}

	ProjectToDominantAxis(dominantAxis, 0); // first vertex
	ProjectToDominantAxis(dominantAxis, 1); // second vertex
	ProjectToDominantAxis(dominantAxis, 2); // third vertex
}