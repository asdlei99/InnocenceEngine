// shadertype=glsl
#version 450
#define BLOCK_SIZE 16

layout(local_size_x = BLOCK_SIZE, local_size_y = BLOCK_SIZE, local_size_z = 1) in;

struct Plane
{
	vec3 N;
	float d;
};

Plane ComputePlane(vec3 p0, vec3 p1, vec3 p2)
{
	Plane plane;

	vec3 v0 = p1 - p0;
	vec3 v2 = p2 - p0;

	plane.N = normalize(cross(v0, v2));
	plane.d = dot(plane.N, p0);

	return plane;
}

struct Frustum
{
	Plane planes[4]; // LRTB
};

struct Sphere
{
	vec3 c;
	float r;
};

bool SphereInsidePlane(Sphere sphere, Plane plane)
{
	return dot(plane.N, sphere.c) - plane.d < -sphere.r;
}

bool SphereInsideFrustum(Sphere sphere, Frustum frustum, float zNear, float zFar)
{
	bool result = true;

	if (sphere.c.z - sphere.r > zNear || sphere.c.z + sphere.r < zFar)
	{
		result = false;
	}

	for (int i = 0; i < 4 && result; i++)
	{
		if (SphereInsidePlane(sphere, frustum.planes[i]))
		{
			result = false;
		}
	}

	return result;
}

vec4 ClipToView(vec4 clip, mat4 in_p_inv)
{
	// View space position.
	vec4 view = in_p_inv * clip;
	// Perspective projection.
	view = view / view.w;

	return view;
}

vec4 ScreenToView(vec4 screen, vec2 in_viewportSize, mat4 in_p_inv)
{
	// Convert to normalized texture coordinates
	vec2 texCoord = screen.xy / in_viewportSize;

	// Convert to clip space
	vec4 clip = vec4(vec2(texCoord.x, 1.0f - texCoord.y) * 2.0f - 1.0f, screen.z, screen.w);

	return ClipToView(clip, in_p_inv);
}

layout(std140, row_major, binding = 7) uniform skyUBO
{
	mat4 p_inv;
	mat4 v_inv;
	vec2 viewportSize;
};

layout(std140, binding = 8) uniform dispatchParamsUBO
{
	uvec3 numThreadGroups;
	uint dispatchParamsUBO_padding1;
	uvec3 numThreads;
	uint dispatchParamsUBO_padding2;
};

layout(std430, binding = 0) buffer gridFrustumsSSBO
{
	Frustum gridFrustums[];
};

void main()
{
	// View space eye position is always at the origin.
	const vec3 eyePos = vec3(0, 0, 0);

	// Compute the 4 corner points on the far clipping plane to use as the
	// frustum vertices.
	vec4 screenSpace[4];
	// Top left point
	screenSpace[0] = vec4(gl_GlobalInvocationID.xy * BLOCK_SIZE, -1.0f, 1.0f);
	// Top right point
	screenSpace[1] = vec4(vec2(gl_GlobalInvocationID.x + 1, gl_GlobalInvocationID.y) * BLOCK_SIZE, -1.0f, 1.0f);
	// Bottom left point
	screenSpace[2] = vec4(vec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y + 1) * BLOCK_SIZE, -1.0f, 1.0f);
	// Bottom right point
	screenSpace[3] = vec4(vec2(gl_GlobalInvocationID.x + 1, gl_GlobalInvocationID.y + 1) * BLOCK_SIZE, -1.0f, 1.0f);

	vec3 viewSpace[4];
	// Now convert the screen space points to view space
	for (int i = 0; i < 4; i++)
	{
		viewSpace[i] = ScreenToView(screenSpace[i], viewportSize, p_inv).xyz;
	}

	// Now build the frustum planes from the view space points
	Frustum frustum;

	// Left plane
	frustum.planes[0] = ComputePlane(eyePos, viewSpace[2], viewSpace[0]);
	// Right plane
	frustum.planes[1] = ComputePlane(eyePos, viewSpace[1], viewSpace[3]);
	// Top plane
	frustum.planes[2] = ComputePlane(eyePos, viewSpace[0], viewSpace[1]);
	// Bottom plane
	frustum.planes[3] = ComputePlane(eyePos, viewSpace[3], viewSpace[2]);

	// Store the computed frustum in global memory (if our thread ID is in bounds of the grid).
	if (gl_GlobalInvocationID.x < numThreads.x && gl_GlobalInvocationID.y < numThreads.y)
	{
		uint index = gl_GlobalInvocationID.x + (gl_GlobalInvocationID.y * numThreads.x);
		gridFrustums[index] = frustum;
	}
}